generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique
  passwordHash     String
  username         String   @unique
  displayName      String
  bio              String   @default("")
  profilePictureUrl String  @default("")
  lastSeen         DateTime @default(now())
  emailVerifiedAt  DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  participants     ConversationParticipant[]
  messages         Message[] @relation("UserMessages")
  friendships      Friendship[] @relation("UserFriendships")
  friendsOf        Friendship[] @relation("FriendFriendships")
  messageHides     MessageHide[]
  emailVerificationTokens EmailVerificationToken[]
  passwordResetTokens     PasswordResetToken[]
}

model Friendship {
  id           String   @id @default(cuid())
  userId       String
  friendId     String
  status       FriendshipStatus @default(pending)
  actionUserId String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user   User @relation("UserFriendships", fields: [userId], references: [id])
  friend User @relation("FriendFriendships", fields: [friendId], references: [id])

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
}

enum FriendshipStatus {
  pending
  accepted
  declined
  blocked
}

model Conversation {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  participants ConversationParticipant[]
  messages     Message[]

  @@index([updatedAt])
}

model ConversationParticipant {
  id             String     @id @default(cuid())
  conversationId String
  userId         String
  lastReadAt     DateTime?
  isPinned       Boolean    @default(false)
  isArchived     Boolean    @default(false)

  conversation Conversation @relation(fields: [conversationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String    @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  type           MessageType @default(text)
  isRead         Boolean   @default(false)
  readAt         DateTime?
  isEdited       Boolean   @default(false)
  isDeleted      Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id])
  sender       User         @relation("UserMessages", fields: [senderId], references: [id])
  attachments  MessageAttachment[]
  hides        MessageHide[]

  @@index([conversationId, createdAt])
}

enum MessageType {
  text
  image
  audio
  file
}

model MessageAttachment {
  id         String  @id @default(cuid())
  messageId  String
  url        String
  mimeType   String
  sizeBytes  Int

  message Message @relation(fields: [messageId], references: [id])
}

model MessageHide {
  id        String  @id @default(cuid())
  messageId String
  userId    String

  message Message @relation(fields: [messageId], references: [id])
  user    User    @relation(fields: [userId], references: [id])

  @@unique([messageId, userId])
}

model LinkPreviewCache {
  id          String   @id @default(cuid())
  url         String   @unique
  title       String?
  description String?
  image       String?
  createdAt   DateTime @default(now())
}

model EmailVerificationToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  user       User     @relation(fields: [userId], references: [id])
}

model PasswordResetToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  user       User     @relation(fields: [userId], references: [id])
}